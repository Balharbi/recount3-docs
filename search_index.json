[
["index.html", "recount3: human and mouse public RNA-seq data Overview How to cite recount3 Team members Teams involved R session information", " recount3: human and mouse public RNA-seq data Overview recount3 is an online resource consisting of RNA-seq gene, exon, and exon-exon junction counts as well as coverage bigWig files for 8,679 and 10,088 different studies for human and mouse respectively. It is the third generation of the ReCount project. The raw sequencing data were processed with recount-pump as described in the recount3 paper which created the coverage bigWig files and the recount-unified text files. While these raw output files are available through IDIES SciServer, for ease of statistical analysis, we provide through the recount3 R/Bioconductor package an interface that builds RangedSummarizedExperiment R objects for gene, exon, and exon-exon junction counts for each study. Furthermore, snapcount enables query-based access of the recount3 and recount2 data. The coverage bigWig files can be used for annotation-agnostic expression analyses using for example megadepth, derfinder and other tools. By taking care of several pre-processing steps and combining many datasets into one easily-accessible website, we make finding and analyzing RNA-seq data considerably more straightforward. How to cite recount3 Thank you for your continued support of the ReCount family of projects! We greatly appreciate you citing our work. print(citation(&quot;recount3&quot;)[2], bibtex = TRUE) ## ## Wilks C, Collado-Torres L, Zheng SC, Jaffe AE, Nellore A, Hansen KD, ## Langmead B (2020). &quot;recount3 pre-print title TODO.&quot; _bioRxiv_. doi: ## 10.1101/TODO (URL: https://doi.org/10.1101/TODO), &lt;URL: ## https://www.biorxiv.org/content/10.1101/TODO&gt;. ## ## A BibTeX entry for LaTeX users is ## ## @Article{, ## title = {recount3 pre-print title TODO}, ## author = {Christopher Wilks and Leonardo Collado-Torres and Shijie C. Zheng and Andrew E. Jaffe and Abhinav Nellore and Kasper D. Hansen and Ben Langmead}, ## year = {2020}, ## journal = {bioRxiv}, ## doi = {10.1101/TODO}, ## url = {https://www.biorxiv.org/content/10.1101/TODO}, ## } Related projects The ReCount project has three main publications over the years with implementation details that have been improved each time. Each phase of the project has had several companion publications that expanded the main resource in different directions. Please cite the appropriate expansions and results as you see relevant for your work. Previous ReCount projects recount2 ReCount Related publications recount3 recount2 ReCount Team members Christopher Wilks (the star behind recount3!) Leonardo Collado Torres Shijie Charles Zheng Teams involved Ben Langmead’s lab at JHU Computer Science Kasper Daniel Hansen’s lab at JHBSPH Biostatistics Department Leonardo Collado-Torres and Andrew E. Jaffe from LIBD Abhinav Nellore’s lab at OHSU Jeff Leek’s lab at JHBSPH Biostatistics Deparment Data hosted by SciServer from IDIES at JHU This book was last updated on 2020-10-30 21:09:08. R session information Details on the R version used for making this book. The source code is available at lcolladotor/bioc_team_ds. ## Load the package at the top of your script library(&quot;sessioninfo&quot;) ## Reproducibility information print(&#39;Reproducibility information:&#39;) Sys.time() proc.time() options(width = 120) session_info() ## For links library(&quot;BiocStyle&quot;) ## Packages illustrated in the documentation library(&quot;recount3&quot;) library(&quot;megadepth&quot;) ## [1] &quot;Reproducibility information:&quot; ## [1] &quot;2020-10-30 21:09:16 UTC&quot; ## user system elapsed ## 8.286 0.469 8.796 ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.3 Patched (2020-10-29 r79387) ## os Ubuntu 20.04.1 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2020-10-30 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [2] RSPM (R 4.0.0) ## Biobase * 2.50.0 2020-10-27 [1] Bioconductor ## BiocFileCache 1.14.0 2020-10-27 [1] Bioconductor ## BiocGenerics * 0.36.0 2020-10-27 [1] Bioconductor ## BiocManager * 1.30.10 2019-11-16 [2] CRAN (R 4.0.3) ## BiocParallel 1.24.0 2020-10-27 [1] Bioconductor ## BiocStyle * 2.18.0 2020-10-27 [1] Bioconductor ## Biostrings 2.58.0 2020-10-27 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.0.2) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.0.2) ## bitops 1.0-6 2013-08-17 [1] RSPM (R 4.0.0) ## blob 1.2.1 2020-01-20 [1] RSPM (R 4.0.0) ## bookdown 0.20 2020-06-23 [1] RSPM (R 4.0.2) ## cli 2.1.0 2020-10-12 [2] RSPM (R 4.0.2) ## cmdfun 1.0.2 2020-10-10 [1] RSPM (R 4.0.2) ## crayon 1.3.4 2017-09-16 [2] RSPM (R 4.0.0) ## curl 4.3 2019-12-02 [2] RSPM (R 4.0.0) ## data.table 1.13.0 2020-07-24 [1] RSPM (R 4.0.2) ## DBI 1.1.0 2019-12-15 [1] RSPM (R 4.0.0) ## dbplyr 1.4.4 2020-05-27 [1] RSPM (R 4.0.0) ## DelayedArray 0.16.0 2020-10-27 [1] Bioconductor ## digest 0.6.25 2020-02-23 [2] RSPM (R 4.0.0) ## dplyr 1.0.2 2020-08-18 [1] RSPM (R 4.0.2) ## ellipsis 0.3.1 2020-05-15 [2] RSPM (R 4.0.0) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.0.0) ## fansi 0.4.1 2020-01-08 [2] RSPM (R 4.0.0) ## fs 1.5.0 2020-07-31 [2] RSPM (R 4.0.2) ## generics 0.0.2 2018-11-29 [1] RSPM (R 4.0.0) ## GenomeInfoDb * 1.26.0 2020-10-27 [1] Bioconductor ## GenomeInfoDbData 1.2.4 2020-10-30 [1] Bioconductor ## GenomicAlignments 1.26.0 2020-10-27 [1] Bioconductor ## GenomicRanges * 1.42.0 2020-10-27 [1] Bioconductor ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.0.2) ## hms 0.5.3 2020-01-08 [1] RSPM (R 4.0.0) ## htmltools 0.5.0 2020-06-16 [2] RSPM (R 4.0.1) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.0.2) ## IRanges * 2.24.0 2020-10-27 [1] Bioconductor ## knitr 1.30 2020-09-22 [2] RSPM (R 4.0.2) ## lattice 0.20-41 2020-04-02 [3] CRAN (R 4.0.3) ## lifecycle 0.2.0 2020-03-06 [2] RSPM (R 4.0.0) ## magrittr 1.5 2014-11-22 [2] RSPM (R 4.0.0) ## Matrix 1.2-18 2019-11-27 [3] CRAN (R 4.0.3) ## MatrixGenerics * 1.2.0 2020-10-27 [1] Bioconductor ## matrixStats * 0.57.0 2020-09-25 [1] RSPM (R 4.0.2) ## megadepth * 0.99.10 2020-10-30 [1] Github (LieberInstitute/megadepth@358abe9) ## memoise 1.1.0 2017-04-21 [2] RSPM (R 4.0.0) ## pillar 1.4.6 2020-07-10 [2] RSPM (R 4.0.2) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.0.0) ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.0.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.0.2) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.0.2) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.0.2) ## R6 2.4.1 2019-11-12 [2] RSPM (R 4.0.0) ## rappdirs 0.3.1 2016-03-28 [1] RSPM (R 4.0.0) ## Rcpp 1.0.5 2020-07-06 [2] RSPM (R 4.0.2) ## RCurl 1.98-1.2 2020-04-18 [1] RSPM (R 4.0.0) ## readr 1.4.0 2020-10-05 [1] RSPM (R 4.0.2) ## recount3 * 0.99.11 2020-10-30 [1] Github (LieberInstitute/recount3@ce25093) ## rlang 0.4.8 2020-10-08 [2] RSPM (R 4.0.2) ## rmarkdown 2.4 2020-09-30 [1] RSPM (R 4.0.2) ## Rsamtools 2.6.0 2020-10-27 [1] Bioconductor ## RSQLite 2.2.1 2020-09-30 [1] RSPM (R 4.0.2) ## rstudioapi 0.11 2020-02-07 [2] RSPM (R 4.0.0) ## rtracklayer 1.50.0 2020-10-27 [1] Bioconductor ## S4Vectors * 0.28.0 2020-10-27 [1] Bioconductor ## sessioninfo * 1.1.1 2018-11-05 [1] RSPM (R 4.0.0) ## stringi 1.5.3 2020-09-09 [2] RSPM (R 4.0.2) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.0.0) ## SummarizedExperiment * 1.20.0 2020-10-27 [1] Bioconductor ## tibble 3.0.4 2020-10-12 [2] RSPM (R 4.0.2) ## tidyselect 1.1.0 2020-05-11 [1] RSPM (R 4.0.0) ## vctrs 0.3.4 2020-08-29 [2] RSPM (R 4.0.2) ## withr 2.3.0 2020-09-22 [2] RSPM (R 4.0.2) ## xfun 0.18 2020-09-29 [2] RSPM (R 4.0.2) ## XML 3.99-0.5 2020-07-23 [1] RSPM (R 4.0.2) ## XVector 0.30.0 2020-10-27 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.0.0) ## zlibbioc 1.36.0 2020-10-27 [1] Bioconductor ## ## [1] /usr/local/lib/R/host-site-library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library "],
["data.html", "1 Data 1.1 Human 1.2 Mouse", " 1 Data recount3 provides processed RNA-seq data for human and mouse in file formats similar to recount2 (Figure 1.1), which at its core is based on coverage bigWig files and exon-exon junction counts (see Raw file for more details). These two raw files power the whole recount3 ecosystem. In recount3, we have provided coverage count files for several human and mouse annotations with samples grouped by study. Some large studies, like GTEx and TCGA have been fragmented at the tissue level to make the data more accessible. Figure 1.1: Overview of the data available in recount2 and recount3. Reads (pink boxes) aligned to the reference genome can be used to compute a base-pair coverage curve and identify exon-exon junctions (split reads). Gene and exon count matrices are generated using annotation information providing the gene (green boxes) and exon (blue boxes) coordinates together with the base-level coverage curve. The reads spanning exon-exon junctions (jx) are used to compute a third count matrix that might include unannotated junctions (jx 3 and 4). Without using annotation information, expressed regions (orange box) can be determined from the base-level coverage curve to then construct data-driven count matrices. 1.1 Human Annotations: Gencode v26 Gencode v29 RefSeq FANTOM6_cat ERCC SIRV 1.2 Mouse "],
["quick-access.html", "2 Quick Access 2.1 Quick recount3 2.2 Quick snapcount 2.3 Quick raw files", " 2 Quick Access The data from the recount3 project is accessible through R/Bioconductor packages as well as raw files. You can access the data through: recount3: this R/Bioconductor package retrieves the data from the IDIES servers and builds RangedSummarizedExperiment objects by study that can be used with many Bioconductor analysis packages for downstream analyses (DOI: 10.1038/nmeth.3252). snapcount: this R/Bioconductor package also provides access to data from recount2 and recount3 through a query-based interface. raw files: these are text files that are hosted by IDIES and can be used with other programming software outside of R. 2.1 Quick recount3 If you want to access the data recount3, here’s some R code that you can use. See the Bioconductor chapter for the full output of these commands and more details. ## Install the recount3 R/Bioconductor package if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;recount3&quot;) ## Load recount3 R package library(&quot;recount3&quot;) ## Find all available human projects human_projects &lt;- available_projects() ## Find the project you are interested in, ## here we use SRP009615 as an example proj_info &lt;- subset( human_projects, project == &quot;SRP009615&quot; &amp; project_type == &quot;data_sources&quot; ) ## Create a RangedSummarizedExperiment (RSE) object at the gene level rse_gene_SRP009615 &lt;- create_rse(proj_info) ## Explore that RSE object rse_gene_SRP009615 2.2 Quick snapcount TODO 2.3 Quick raw files The raw recount3 files are hosted by IDIES and are publicly available. We separated every piece of information into its own file. These files can be accessed without using R through your own favorite programming solution. For example, the files for human study SRP009615 annotated with GENCODE v26 are: Metadata files: http://idies.jhu.edu/recount3/data/human/data_sources/sra/metadata/15/SRP009615/sra.sra.SRP009615.MD.gz http://idies.jhu.edu/recount3/data/human/data_sources/sra/metadata/15/SRP009615/sra.recount_project.SRP009615.MD.gz http://idies.jhu.edu/recount3/data/human/data_sources/sra/metadata/15/SRP009615/sra.recount_qc.SRP009615.MD.gz http://idies.jhu.edu/recount3/data/human/data_sources/sra/metadata/15/SRP009615/sra.recount_seq_qc.SRP009615.MD.gz http://idies.jhu.edu/recount3/data/human/data_sources/sra/metadata/15/SRP009615/sra.recount_pred.SRP009615.MD.gz Gene files: http://idies.jhu.edu/recount3/data/human/data_sources/sra/gene_sums/15/SRP009615/sra.gene_sums.SRP009615.G026.gz Annotation files: http://idies.jhu.edu/recount3/data/human/annotations/gene_sums/human.gene_sums.G026.gtf.gz If you are interested in exploring what are the available projects in recount3, you might be interested in accessing: http://idies.jhu.edu/recount3/data/human/data_sources/sra/metadata/sra.recount_project.MD.gz http://idies.jhu.edu/recount3/data/human/data_sources/gtex/metadata/gtex.recount_project.MD.gz http://idies.jhu.edu/recount3/data/human/data_sources/tcga/metadata/tcga.recount_project.MD.gz For more details about the structure of these files, check the Raw Files chapter. "],
["study-explorer.html", "3 Study explorer", " 3 Study explorer We can embed shiny web applications here "],
["how-to-ask-for-help.html", "4 How to ask for help 4.1 Gitter 4.2 Bioconductor Support website 4.3 GitHub Issues", " 4 How to ask for help something about avoiding emails sharing your questions enables us to help more people like you 4.1 Gitter 4.2 Bioconductor Support website 4.3 GitHub Issues "],
["quality-check-fields.html", "5 Quality check fields", " 5 Quality check fields We used a number of tools to collect potentially useful quality-control (QC) measures. Specifically, we used seqtk (Li, n.d.), the idxstats subcommand of samtools, the output of STAR, our own megadepth tool, and featureCounts. We examine each in turn, listing the specific QC measures calculated be each. Monorail runs the seqtk fqchk command on input FASTQ files to collect base-quality and base-composition summaries for all sequencing cycles. We distill these into a few QC measures included with every summarized run in recount3. min_len: minimum read length max_len: maximum read length avg_len: average read length #distinct_quality_values: number of different quality scores present in the sequence run’s base qualities #bases: total number of bases across spots (not including both read mates if paired) %A: percent of bases that are A %C: percent of bases that are C %G: percent of bases that are G %T: percent of bases that are T %N: percent of bases that are N avgQ: weighted average over Phred quality scores present in the sequence run, where weights are the Phred quality values themselves errQ: negatively scaled log of the weighted average Phred quality scores present in the sequence run, where weights are the error probabilities associated with the Phred quality scores Monorail uses STAR to align RNA-seq reads in a spliced fashion to a reference genome, without using any annotation. Files output by STAR, particularly the Log.out and Log.final.out, report a number of measures that can be used for QC. We compile these into a number of QC measures included with every summarized run in recount3. Note that some of these measures are reported separately for the two ends of a paired-end read. We omit the second-end versions of these QC measures here for space reasons. From the STAR manual (version 2.7.2b): Log.final.out: summary mapping statistics after mapping job is complete, very useful for quality control. The statistics are calculated for each read (single- or paired-end) and then summed or averaged over all reads. Note that STAR counts a paired-end read as one read, (unlike the samtools flagstat/idxstats, which count each mate separately). Most of the information is collected about the UNIQUE mappers (unlike samtools flagstat/idxstats which does not separate unique or multi-mappers). Each splicing is counted in the numbers of splices, which would correspond to summing the counts in SJ.out.tab. The mismatch/indel error rates are calculated on a per base basis, i.e. as total number of mismatches/indels in all unique mappers divided by the total number of mapped bases. Some of the following definitions include text from the STAR manual/source code, reprinted here for convenience. Please see the STAR manual for more in depth information. %_of_chimeric_reads: Number of chimeric reads divided by number of input reads %_of_reads_mapped_to_multiple_loci: Number of reads mapped to multiple loci divided by number of input reads %_of_reads_mapped_to_too_many_loci: Number of reads mapped to (&gt; 10) loci divided by number of input reads %_of_reads_unmapped:_other: Reads are unmapped due to no acceptable seed/windows divided by number of input reads %_of_reads_unmapped:_too_many_mismatches: Number of reads where best alignment has more mismatches than max allowed number of mismatches divided by number of input reads %_of_reads_unmapped:_too_short: Number of reads where best alignment was shorter than min allowed mapped length divided by number of input reads all_mapped_reads: Total number of reads aligned average_input_read_length: Average length of a read average_mapped_length: Average length of an alignment deletion_average_length: Average length of a genomic deletion, i.e. genomic gaps deletion_rate_per_base: Genomic deletions per mapped base insertion_average_length: Average length of a genomic insertion, i.e. read gaps insertion_rate_per_base: Genomics insertions per mapped base mapping_speed_million_of_reads_per_hour: How fast it was to align this sample mismatch_rate_per_base_%: Mismatches per mapped base number_of_chimeric_reads: Total number of reads which were fragmented on aligning, e.g. fusion potential reads number_of_input_reads: Total number of reads input to STAR number_of_reads_mapped_to_multiple_loci: Number of reads mapped to multiple loci number_of_reads_mapped_to_too_many_loci: Number of reads mapped to (&gt; 10) loci number_of_reads_unmapped:_other: Number of reads left unmapped due to no acceptable seed/windows number_of_reads_unmapped:_too_many_mismatches: Number of reads where best alignment has more mismatches than max allowed number of mismatches number_of_reads_unmapped:_too_short: Number of reads where best alignment was shorter than min allowed mapped length number_of_splices:_at/ac: Number of canonical splices of AT-AC (and reverse) number_of_splices:_annotated_(sjdb): Number of splices found that were also in the annotation database number_of_splices:_gc/ag: Number of canonical splices of GC-AG (and reverse) number_of_splices:_gt/ag: Number of canonical splices of GT-AG (and reverse) number_of_splices:_non-canonical: Number of non-canonical splices, anything not GT-AG, AT-AC, GC-AG, or their reverse complement number_of_splices:_total: Total number of splices uniquely_mapped_reads_%: Number of reads which mapped to a single locus divided by number of input reads uniquely_mapped_reads_number: Number of reads which mapped to a single locus Monorail runs the samtools idxstats on the BAM file output by STAR to collect statistics about how many reads aligned to each chromosome in the genome assembly. This can be helpful in, for instance, confirming the sex of the individual sequenced based on alignments to sex chromosomes, or measuring effectiveness of ribosomal RNA depletion by considering the fraction of reads aligned to the mitochondrial genome. We compile these into a number of QC measures included with every summarized run in recount3: aligned_reads%.chrm: Percent of reads aligning to the mitochondrial genome. aligned_reads%.chrx: Percent of reads aligning to chromosome X. aligned_reads%.chry: Precent of reads aligning to chromosome Y. Monorail runs our megadepth tool on the BAM files output by STAR. The chief function is to convert BAM files to bigWig files that are then added to the recount3 archive. As megadepth performs this conversion, it also summarizes the amount of sequencing coverage within the intervals of a provided BED file representing a gene annotation. These quantifications can be useful for quality control, tell us, for example, what fraction of the coverage is within annotated genes. Fragment length distribution is based on a special read filter only applied for this purpose to be compatible with CSAW’s fragment counting approach (Lun and Smyth 2016), paired reads in a passing fragment must not be secondary, supplementary, have conflicting read order, be unmapped or be mapped on more than one chromosome. The bc_ prefix here refers to the previous name of the Megadepth tool.1 bc_auc.all_reads_all_bases: Area under coverage (total depth of coverage evaluated at all bases) for all alignments bc_auc.all_reads_annotated_bases: Area under coverage for all alignments, but only for bases in annotated exons bc_auc.unique_reads_all_bases: Area under coverage for uniquely aligned reads bc_auc.unique_reads_annotated_bases: Area under coverage for uniquely aligned reads, but only for bases in annotated exons bc_auc.all_%: bc_auc.all_reads_annotated_bases divided by bc_auc.all_reads_all_bases bc_auc.unique_%: bc_auc.unique_reads_annotated_bases divided by bc_auc.unique_reads_all_bases bc_frag.count: Total number of read fragments in BAM after filtering bc_frag.kallisto_count: Number of read fragments (&lt; 1000) bp in length in BAM after filtering bc_frag.kallisto_mean_length: Mean length of read fragments (&lt; 1000) bp in length in BAM after filtering bc_frag.mean_length: Mean length of all read fragments in BAM after filtering bc_frag.mode_length: Mode of the read fragment length of all fragments in BAM after filtering bc_frag.mode_length_count: Number of read fraqments with the bc_frag.mode_length in BAM after filtering Finally, Monorail runs featureCounts on the BAM files output by STAR. This provides a second opinion on the quantifications produced by megadepth. While we have not yet found compelling examples where the megadepth and featureCounts outputs disagree, we keep summaries of the featureCounts quantifications as potential QC measures. exon_fc.all_%: exon_fc_count_all.assigned divided by all_mapped_reads (from STAR) exon_fc.unique_%: exon_fc_count_unique.assigned divided by uniquely_mapped_reads_number (from STAR) exon_fc_count_all.total: Total number of fragments, including multi-mappers, input to featureCounts exon_fc_count_all.assigned: Number of fragments, including multi-mappers, assigned by featureCounts to an exon exon_fc_count_unique.total: Total number of uniquely mapping fragments input to featureCounts exon_fc_count_unique.assigned: Number of uniquely mapping fragments assigned by featureCounts to an exon gene_fc.all_%: gene_fc_count_all.assigned divided by all_mapped_reads (from STAR) gene_fc.unique_%: gene_fc_count_unique.assigned divided by uniquely_mapped_reads_number (from STAR) gene_fc_count_all.total: Total number of fragments, including multi-mappers, input to featureCounts gene_fc_count_all.assigned: Number of fragments, including multi-mappers, assigned by featureCounts to a gene gene_fc_count_unique.total: Total number of uniquely mapping fragments input to featureCounts gene_fc_count_unique.assigned: Number of uniquely mapping fragments assigned by featureCounts to a gene References "],
["bioconductor.html", "6 Bioconductor 6.1 recount3 6.2 snapcount 6.3 megadepth", " 6 Bioconductor R is an open source software programming language that has been widely used for studying gene expression data thanks in part to the Bioconductor project. You can install R for free from CRAN on macOS, Windows, and Linux operating systems. The Bioconductor community has defined common structures that enable users to store their data in common formats and analyzed through many different solutions (DOI: 10.1038/nmeth.3252). One such common format is the RangedSummarizedExperiment object from the SummarizedExperiment package that can then be used in downstream analayses of differential expression using packages such as DESeq2, edgeR, and limma. To facilitate the re-analysis of public expression data, we have provided several R/Bioconductor packages that interface with the recount3 data. These are: recount3 snapcount megadepth These packages can also benefit from using recount and derfinder, which we made in earlier phases of the ReCount project. 6.1 recount3 The following information is taken from the recount3 documentation. After installing recount3, we need to load the package, which will automatically load the required dependencies. ## Load recount3 R package library(&quot;recount3&quot;) If you have identified a study of interest and want to access the gene level expression data, use create_rse() as shown below. create_rse() has arguments that will allow you to specify the annotation of interest for the given organism, and whether you want to download gene, exon or exon-exon junction expression data. ## Find all available human projects human_projects &lt;- available_projects() ## using temporary cache /tmp/Rtmps85Cpt/BiocFileCache ## 2020-10-30 21:09:16 caching file sra.recount_project.MD.gz. ## adding rname &#39;http://idies.jhu.edu/recount3/data/human/data_sources/sra/metadata/sra.recount_project.MD.gz&#39; ## 2020-10-30 21:09:17 caching file gtex.recount_project.MD.gz. ## adding rname &#39;http://idies.jhu.edu/recount3/data/human/data_sources/gtex/metadata/gtex.recount_project.MD.gz&#39; ## 2020-10-30 21:09:18 caching file tcga.recount_project.MD.gz. ## adding rname &#39;http://idies.jhu.edu/recount3/data/human/data_sources/tcga/metadata/tcga.recount_project.MD.gz&#39; ## Find the project you are interested in, ## here we use SRP009615 as an example proj_info &lt;- subset( human_projects, project == &quot;SRP009615&quot; &amp; project_type == &quot;data_sources&quot; ) ## Create a RangedSummarizedExperiment (RSE) object at the gene level rse_gene_SRP009615 &lt;- create_rse(proj_info) ## 2020-10-30 21:09:23 downloading and reading the metadata. ## 2020-10-30 21:09:23 caching file sra.sra.SRP009615.MD.gz. ## adding rname &#39;http://idies.jhu.edu/recount3/data/human/data_sources/sra/metadata/15/SRP009615/sra.sra.SRP009615.MD.gz&#39; ## 2020-10-30 21:09:23 caching file sra.recount_project.SRP009615.MD.gz. ## adding rname &#39;http://idies.jhu.edu/recount3/data/human/data_sources/sra/metadata/15/SRP009615/sra.recount_project.SRP009615.MD.gz&#39; ## 2020-10-30 21:09:24 caching file sra.recount_qc.SRP009615.MD.gz. ## adding rname &#39;http://idies.jhu.edu/recount3/data/human/data_sources/sra/metadata/15/SRP009615/sra.recount_qc.SRP009615.MD.gz&#39; ## 2020-10-30 21:09:24 caching file sra.recount_seq_qc.SRP009615.MD.gz. ## adding rname &#39;http://idies.jhu.edu/recount3/data/human/data_sources/sra/metadata/15/SRP009615/sra.recount_seq_qc.SRP009615.MD.gz&#39; ## 2020-10-30 21:09:24 caching file sra.recount_pred.SRP009615.MD.gz. ## adding rname &#39;http://idies.jhu.edu/recount3/data/human/data_sources/sra/metadata/15/SRP009615/sra.recount_pred.SRP009615.MD.gz&#39; ## 2020-10-30 21:09:25 downloading and reading the feature information. ## 2020-10-30 21:09:25 caching file human.gene_sums.G026.gtf.gz. ## adding rname &#39;http://idies.jhu.edu/recount3/data/human/annotations/gene_sums/human.gene_sums.G026.gtf.gz&#39; ## 2020-10-30 21:09:26 downloading and reading the counts: 12 samples across 63856 features. ## 2020-10-30 21:09:26 caching file sra.gene_sums.SRP009615.G026.gz. ## adding rname &#39;http://idies.jhu.edu/recount3/data/human/data_sources/sra/gene_sums/15/SRP009615/sra.gene_sums.SRP009615.G026.gz&#39; ## 2020-10-30 21:09:27 construcing the RangedSummarizedExperiment (rse) object. ## Explore that RSE object rse_gene_SRP009615 ## class: RangedSummarizedExperiment ## dim: 63856 12 ## metadata(8): time_created recount3_version ... annotation recount3_url ## assays(1): raw_counts ## rownames(63856): ENSG00000278704.1 ENSG00000277400.1 ... ENSG00000182484.15_PAR_Y ENSG00000227159.8_PAR_Y ## rowData names(10): source type ... havana_gene tag ## colnames(12): SRR387777 SRR387778 ... SRR389077 SRR389078 ## colData names(175): rail_id external_id ... recount_pred.curated.cell_line BigWigURL You can also interactively choose your study of interest ## Note that you can interactively explore the available projects proj_info_interactive &lt;- interactiveDisplayBase::display(human_projects) ## Select a single row, then hit &quot;send&quot;. The following code checks this. stopifnot(nrow(proj_info_interactive) == 1) ## Then create the RSE object rse_gene_interactive &lt;- create_rse(proj_info_interactive) Once you have a RSE file, you can use transform_counts() to transform the raw coverage counts. ## Once you have your RSE object, you can transform the raw coverage ## base-pair coverage counts using transform_counts(). ## For RPKM, TPM or read outputs, check the details in transform_counts(). assay(rse_gene_SRP009615, &quot;counts&quot;) &lt;- transform_counts(rse_gene_SRP009615) Now you are ready to continue with downstream analysis software. recount3 also supports accessing the BigWig raw coverage files as well as specific study or collection sample metadata. Please continue to the users guide for more detailed information. 6.2 snapcount 6.3 megadepth The following information is taken from the megadepth documentation. To get started, we need to load the megadepth package into our R session. This will load all the required dependencies. library(&quot;megadepth&quot;) Once we have the R package loaded, we need to install the Megadepth software. We can do so with install_megadepth(), which downloads a binary for your OS (Linux, Windows or macOS).2 We can then use with an example BigWig file to compute the coverage at a set of regions. ## Install the latest version of Megadepth install_megadepth(force = TRUE) ## The latest megadepth version is 1.0.8 ## megadepth has been installed to /github/home/bin Next, we might want to use megadepth to quantify the coverage at a set of regions of the genome of interest to us. Here we will use two example files that are include in the package for illustration and testing purposes. One of them is a bigWig file that contains the base-pair coverage information for a sample of interest and the second one is BED file which contains the genomic region coordinates of interest. So we first locate them. ## Next, we locate the example BigWig and annotation files example_bw &lt;- system.file(&quot;tests&quot;, &quot;test.bam.all.bw&quot;, package = &quot;megadepth&quot;, mustWork = TRUE ) annotation_file &lt;- system.file(&quot;tests&quot;, &quot;testbw2.bed&quot;, package = &quot;megadepth&quot;, mustWork = TRUE ) ## Where are they? example_bw ## [1] &quot;/usr/local/lib/R/host-site-library/megadepth/tests/test.bam.all.bw&quot; annotation_file ## [1] &quot;/usr/local/lib/R/host-site-library/megadepth/tests/testbw2.bed&quot; Once we have located the example files we can proceed to calculating the base-pair coverage for our genomic regions of interest. There are several ways to do this with megadepth, but here we use the user-friendly function get_coverage(). This function will perform a given operation op on the bigWig file for a given set of regions of interest (annotation). One of those operations is to compute the mean base-pair coverage for each input region. This is what we’ll do with our example bigWig file. ## We can then use megadepth to compute the coverage bw_cov &lt;- get_coverage( example_bw, op = &quot;mean&quot;, annotation = annotation_file ) bw_cov ## GRanges object with 4 ranges and 1 metadata column: ## seqnames ranges strand | score ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; ## [1] chr10 0-10 * | 0.00 ## [2] chr10 8756697-8756762 * | 15.85 ## [3] chr10 4359156-4359188 * | 3.00 ## [4] GL000219.1 168500-168620 * | 1.26 ## ------- ## seqinfo: 2 sequences from an unspecified genome; no seqlengths get_coverage() returns an object that is familiar to GenomicRanges users, that is, a GRanges object that can be used with other Bioconductor software packages. This example is just the tip of the iceberg, as Megadepth and thus megadepth can do a lot of useful processing operations on BAM and bigWig files. Please continue to the users guide for more detailed information. Please check Megadepth for instructions on how to compile the software from source if the binary version doesn’t work for you.↩︎ "],
["raw-files.html", "7 Raw Files 7.1 Data source vs collection", " 7 Raw Files Explain the raw file formats we have and how they are organized 7.1 Data source vs collection "],
["bigwig-tools.html", "8 bigWig tools", " 8 bigWig tools megadepth "],
["related-software.html", "9 Related software", " 9 Related software "],
["related-analyses.html", "10 Related analyses", " 10 Related analyses "],
["your-data.html", "11 Your data 11.1 Process your data 11.2 Contribute your collections", " 11 Your data 11.1 Process your data Info on how to use recount-pump for your own private data this is experimental 11.2 Contribute your collections How to build a collection and send that information to us "],
["join-the-recount-team.html", "12 Join the ReCount team!", " 12 Join the ReCount team! We have multiple positions available! The ReCount project involves the Hansen, Leek, Langmead and Battle labs at JHU &amp; the Nellore lab at OHSU &amp; the Collado-Torres lab at LIBD. Contact: Kasper D. Hansen Ben Langmead Leonardo Collado-Torres Abhinav Nellore Alexis Battle Jeff Leek "]
]
